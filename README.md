hvips : haskell bindings for libvips
====================================

Experimental API for the [libvips](https://libvips.github.io/libvips/) image processing library, using the low-level [gi-vips](https://hackage.haskell.org/package/gi-vips-8.0.1) GObject introspection bindings.

## Status

Proof-of-concept only, but functional. Includes code for all libvips v8.10.6 operations. Sample `hvips-exe` demonstrates applying an inverse transform and saving an image, with no GObject memory leaks.

Still TODO:
* Support returning 'flags' values from operations (e.g. `GI.Vips.ForeignFlags`).
* Support custom 'VipsSource' and 'VipsTargets', with callbacks to read/write image data.

It is also likely that changes will be required to support _mutable_ operations such as the various `DrawXXX` operations. See, for example, [ruby-vips](https://libvips.github.io/libvips/2021/03/08/ruby-vips-mutate.html) and [netvips](https://github.com/kleisauke/net-vips/issues/119) references for this issue.

## Quick-start

Install `libvips`; this is an external dependency, not managed by stack or cabal. Recommended version is 8.10.6.

Build and run the sample app via stack.

Run:
```console
stack exec hvips-exe -- -c <infile> <outfile>`
```

Infile and outfile may be different types. The type of outfile is determined by the file extension, e.g `hvips.exe img.jpg img.png`. Supported image types depend on the build of libvips; see the [libvips README](https://github.com/libvips/libvips#optional-dependencies).

### Testing

To run tests with vips memory leak checking, run:
```console
VIPS_LEAK=true stack test
```
## Hacking hvips

Much of the code is auto-generated by introspection over libvips, using the low-level gi-vips capabilities.

To re-generate hvips code (e.g. for a different version of libvips), install the desired version of libvips and then run:
```console
./mkvips.sh && stack build
```
